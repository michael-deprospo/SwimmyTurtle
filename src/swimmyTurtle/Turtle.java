package swimmyTurtle;

import java.awt.Color;
import java.awt.Font;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
//[skeleton0
import java.util.*;

import javax.swing.JLabel;

import visual.dynamic.described.*;
import visual.statik.TransformableContent;

/**
 * Turtle class that can jump Note: This is a simple rule-based Sprite. Hence, it has rules in
 * handleTick().
 *
 * @author Michael DeProspo
 * @version 1.0
 */
public class Turtle extends RuleBasedSprite implements KeyListener
{
  protected double initialSpeed, maxX, maxY, speed, x, y;
  protected boolean jump = false;
  public int points = 0;
  public int buffer = 7;
  protected JLabel text;
  protected boolean alive = true;
  public Stage stage;
  private int width;
  private int height;

  /**
   * Explicit Value Constructor
   *
   * @param content
   *          The static visual content
   * @param width
   *          The width of the Stage
   * @param height
   *          The height of the Stage
   * @param speed
   *          The normal speed
   */
  public Turtle(TransformableContent content, double width, double height, double speed,
      JLabel pointText, Stage stage)
  {
    super(content);
    maxX = width;
    maxY = height;
    this.width = (int) width;
    this.height = (int) height;
    this.stage = stage;
    text = pointText;
    x = 0;
    y = height / 2;

    this.initialSpeed = speed;
    this.speed = speed;
  }

  /**
   * Handle a tick event (generated by the Stage)
   *
   * @param time
   *          The current time (which is not used)
   */
  public void handleTick(int time)
  {
    Iterator<Sprite> i;
    Sprite straw;
    points++;
    text.setText("Points: " + points / 10);

    alive = false;
    i = antagonists.iterator();
    while (i.hasNext())
    {
      straw = i.next();

      if (intersects(straw))
      {
        buffer -= 1;
        if (buffer <= 0)
        {
          deadTurtle();
          stage.stop();
        }
      }
    }
    if (jump)
    {
      y -= 12;
    }
    else
    {
      y += 3;
    }
    jump = false;
    updateLocation();
  }

  /**
   * Update the location
   */
  protected void updateLocation()
  {

    setLocation(x, y);
  }

  /**
   * Handles logic when turtle collides. Sets "end screen".
   */
  public void deadTurtle()
  {
    alive = false;
    text.setLocation(width / 2, height / 2);
    text.setBounds(0, height / 2, width, 100);
    text.setText("You died :( Hit 'r' to restart!");
  }

  @Override
  public void keyTyped(KeyEvent e)
  {
    switch (e.getKeyChar())
    {
      case ' ':
        jump = true;
        break;
      case 'a':
        jump = true;
        break;
      case 'r':
        if (!alive)
        {
          stage.repaint();
          buffer += 1;
          reset();
          stage.start();
        }
    }

  }

  /**
   * Resets turtle to starting position and resets points. Resets straws speed and locations.
   */
  public void reset()
  {
    x = 0;
    y = height / 2;
    alive = true;
    points = 0;
    text.setForeground(Color.WHITE);
    text.setFont(new Font("Verdana", Font.BOLD, 24));
    text.setBounds(width - 150, 30, 150, 50);
    text.setText("Points: " + points);
    Iterator<Sprite> i;
    Straw straw;
    i = antagonists.iterator();
    while (i.hasNext())
    {
      straw = (Straw) i.next();
      straw.reset();    
    }
  }

  @Override
  public void keyPressed(KeyEvent e)
  {
    // TODO Auto-generated method stub

  }

  @Override
  public void keyReleased(KeyEvent e)
  {
    // TODO Auto-generated method stub

  }
}
